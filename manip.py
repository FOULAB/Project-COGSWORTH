#!/usr/bin/env pypy
# These make division and print work like in python 3, making the code compatible in
# both versions - __future__ imports MUST come first.
# This makes / return floats and // return ints.
from __future__ import division
# This makes print require ().
from __future__ import print_function

# Make sure that we are using the generator function for range in both python 2 and 3.
# (In python 3 range is like xrange, and xrange doesn't exist)
import builtins
if hasattr(builtins, 'xrange'):
    range = xrange

# Standard libraries.
import argparse
import glob
import os
import re
import time

# 3rd party packages.
from PIL import Image
import multiprocessing as mp
import numpy
import tqdm


def get_arguments():
    """
    Parse arguments from the command line.

    :returns: The argument namespace.
    :rtype:   Namespace (like a dictionary)
    """
    parser = argparse.ArgumentParser(description='Analyze data generated by Cogsworth.')

    parser.add_argument(
        'data_folder',
        type=str,
        help='The folder which contains the dmp files.',
    )

    return parser.parse_args()


def get_stamp_and_resolution(data_folder):
    """
    Gets the resolution of the image by parsing the names of the files in the data
    folder.

    :param data_folder: The data folder in which the sample dmps are located.
    :type data_folder:  str
    """
    # Get a list of all of the data files in the folder.
    data_files = glob.glob(os.path.join(data_folder, 'SAMPLE_*.dmp'))

    # Get the stamp from the files using regular expressions.
    stamp_regexp = re.compile(r'.+SAMPLE_(\d+).+')
    stamp = stamp_regexp.match(data_files[0]).groups()[0]

    # Create a regular expression to extract the information out of the file names.
    file_regexp = re.compile(r'.+SAMPLE_\d+_(\d+)_(\d+).dmp')

    # Use numpy to convert all of the data to integers and get the maximum of horizontal
    # and vertical.
    sizes = numpy.array([file_regexp.match(f).groups() for f in data_files]).astype(numpy.int)

    # We convert explicitely to int because these are numpy.int64, and we get an error
    # if we use those in list indices.
    return stamp, int(numpy.max(sizes[:, 0])), int(numpy.max(sizes[:, 1]))


def processing(params):
    """
    Process the data from a specific file.

    :param params: The parameters required for parsing the data file.
    :type params:  tuple

    :returns: The calculated color for the pixel, along with some of
              the input information.
    :rtype:   tuple
    """
    pFolder, pStamp, pI, pJ, VER, HOR, _ = params

    # Grab the data from the data file.
    filename = os.path.join(
        pFolder,
        'SAMPLE_{0}_{1}_{2}.dmp'.format(pStamp, str(pI), str(pJ)),
    )
    tech = numpy.fromfile(filename, numpy.float32)

    # Calculate the average color for the measurement.
    # // is broken for numpy, so we int cast.
    average = numpy.average(tech)
    colour = int(average * 255 // 100)

    hold = (pI, pJ, VER, HOR, colour)

    return hold


def main():
    args = get_arguments()

    # Get the time in order to inform the user how long the processing took.
    start = time.time()

    # Grab the resolution by parsing the data file names.
    stamp, horizontal, vertical = get_stamp_and_resolution(args.data_folder)

    # Create an empty image, into which we will put out data.
    IMG = Image.new('RGB', (horizontal, vertical), 'black')
    PIXELS = IMG.load()

    # Create the file processing queue.
    DUMPS = []
    for i in range(horizontal):
        for j in range(vertical):
            DUMPS.append([args.data_folder, stamp, i, j, vertical, horizontal, 0])

    # Create a threadpool and process the data.
    pewl = mp.Pool(3)
    print('Processing...')

    for PXL in tqdm.tqdm(pewl.imap_unordered(processing, DUMPS), total=len(DUMPS)):
        # correcting for even vertical pixel data being generated
        # from and upward sweep of the antenna, and vice versa for the odd case
        if PXL[0] // 2 == PXL[0] / 2:
            reverse = 0
        else:
            reverse = vertical - 1

        PIXELS[horizontal - 1 - PXL[0], abs(PXL[1] - reverse)] = (PXL[4], PXL[4], PXL[4])

    print('Done. Processing took: %d s.' % int(time.time() - start))

    IMG.show()


if __name__ == '__main__':
    main()
